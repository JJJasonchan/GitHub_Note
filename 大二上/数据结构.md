## 绪论

数据结构就是**研究关于数据表达，数据存储及数据处理的方法**。

### 数据 数据元素 数据项

- [[数据]]：一切能输入到计算机中被计算机程序处理的信息
- **[[数据元素]]**：*数据的基本单位*，通常作为一个整体考虑和处理
- **[[数据项]]：构成数据元素的成份，是==数据不可分割的最小单位==**

> 注意，每个数据元素可以有一个数据项，也可以由若干数据项组成


### 数据对象 结构 数据结构

- **[[数据对象]]**：具有相同特性的数据元素的一个集合,*是数据的子集*
- **结构**：数据元素之间的关系
- [[数据结构定义]]**：相互之间存在一种或多种特定关系的数据元素的集合，即带结构的数据元素的集合

> 即是带有某种关系的数据的结合



---

### 逻辑关系 数据存储

**逻辑关系**可以分为：

- 集合关系
- 线性关系---**线性**数据结构
- 层次关系---**层次**数据结构
- 网状关系---**网状**数据结构


数据在计算机存储的方式：

1. **顺序**：数据元素逐个连续存放
2. **非顺序**：数据任意存放（通过存储地址确定关系）



---

### 算法

**算法**是对特定问题求解步骤的一种描述,它是指令的有限序列,其中每一条指令表示一种或多种操作.

**算法的基本特征：**
1. **输入**：0个或多个输入；
2. **输出**：1个或多个输出；
3. **有穷性**：算法必须在有限步内结束；
4. **确定性**：组成算法的操作必须清晰无二义性。
5. **可行性**：组成算法的操作必须能够在计算机上实现。

#### 时间复杂度

**时间复杂度（Time Complexity）** 是衡量一个算法运行时间随输入规模（n）变化的增长趋势。

它反映的是 **算法效率的上界**，而不是具体的运行时间（因为具体时间跟硬件、编译器都有关）。 简单理解：**时间复杂度 ≈ 算法运行所需步骤数随输入规模变化的数量级**。

常见的时间复杂度：

- O(1)—常数阶:一些运算次数为常数的算法O(N)—线性阶

  ```c
  temp=a;
  a=b;
  b=temp;
  ```

- O(N)—对数阶:一些线性算法(循环)

  ```c
  sum=0;
  for(i=0;i<n;i++)
  {
  	sum++;
  }
  ```

- O($log2N$)—线性对数阶:二分查找

- O($n^2$)—平方阶：*嵌套循环*

  ```c
  for(int i=0;i<n;i++)
  {
  	for(int j=0;j<n;j++)
  	{
  		pass;
  	}
  }
  ```

  ---
  
## DS-线性表
  
[[线性表]]定义：线性表具有相同数据类型的n个（n>=0）个数据元素的有限队列通常记为：
(a1，a2，… ai-1，ai，ai+1，…an)，其中ai是[[数据元素]] ,n为表长，n＝0 时称为空表。

[[线性关系]]：**除了第一外**，每个数据元素均有且只有一个前驱；**除了最后一个外**，每个数据元素均有且只有一个后继元素。
> 记得要有前面的前置条件，考试判断题会有

特点：数据元素之间的关系是他们在数据集合中的相对位置

---
### 线性表上常见运算

- **InitList(&L)**
    - **操作结果：** **构造**一个空的线性表L。

- **DestroyList(&L)**
    - **初始条件：** 线性表L已经存在。
        
    - **操作结果：** 销毁线性表L。

- **ClearList(&L)**
    
    - **初始条件：** 线性表L已经存在。
        
    - **操作结果：** 将线性表L重置为空表。

- **ListEmpty(L)**
    
    - **初始条件：** 线性表L已经存在。
        
    - **操作结果：** 若线性表L为空表，则返回TRUE；否则返回FALSE。

- **ListLength(L)**
    
    - **初始条件：** 线性表L已经存在。
        
    - **操作结果：** 返回线性表L中的数据元素个数。

- **GetElem(L, i, &e)**
    
    - **初始条件：** 线性表L已经存在，1≤i≤ListLength(L)。
        
    - **操作结果：** 用e返回线性表L中第i个数据元素的值。

- **LocateElem(L, e, compare())**
    
    - **初始条件：** 线性表L已经存在，compare()是数据元素判定函数。
        
    - **操作结果：** 返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。

- **PriorElem(L, cur_e, &pre_e)**
    
    - **初始条件：** 线性表L已经存在。
        
    - **操作结果：** 若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱；否则操作失败，pre_e无意义。

- **NextElem(L, cur_e, &next_e)**
    
    - **初始条件：** 线性表L已经存在。
        
    - **操作结果：** 若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继；否则操作失败，next_e无意义。

- **ListDelete(&L, i, &e)**
    
    - **初始条件：** 线性表L已经存在，1≤i≤ListLength(L)。
        
    - **操作结果：** 删除L的第i个数据元素，并用e返回其值，L的长度减1。

- **ListInsert(&L, i, e)**
    
    - **初始条件：** 线性表L已经存在，1≤i≤ListLength(L)+1。
        
    - **操作结果：** 在L的第i个位置之前插入新的数据元素e，L的长度加1。

---
### 顺序存储结构

**特点**：
- 存储空间必须连续，预分配
- 逻辑顺序与物理顺序一致，用物理上相邻来表示逻辑上的线性关系。
- 任意相邻元素之间无空闲空间,且相距为L.
- 已知基地址,可以计算出任意元素的存储地址:  `LOC(ai)=base+(i-1)*L`

### 虚拟实现

在高级语言中，用高级语言中的数字说明上面的存储方式。
```c
#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量
#define LISTINCREMENT 10 //线性表存储空间的分配增量
typedef struct {
    Elemtype *elem; //存储空间基址
    int length; //当前长度
    int listsize; //当前分配存储容量(以sizeof(Elemtype)为单位)
}SqList;
```

基本操作如下实现

- `InitList(&L)`结构初始化
- `LocateElem(L,e,compare())`查找
- `ListInsert(&L,i,e)`插入
- `ListDelete(&L,i)`删除元素

接下来是具体函数的实现：
- `InitList(&L)`结构初始化
```C++
//初始化数据
  Status InitList_Sq(SqList &L) {
    // 构造一个空的线性表
    L.elem = (ElemType*) malloc(LIST_INIT_SIZE*sizeof(ElemType));
    if (!L.elem) exit(OVERFLOW);//申请相应大小的空间

    L.length = 0;
    L.listsize = LIST_INIT_SIZE;

    return OK;
} // InitList_Sq
```

> 算法时间复杂度：O(1)

- `ListInsert(&L,i,e)`实现

```cpp
// 插入：在第 i 个位置之前插入新元素 e
Status ListInsert_Sq(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) return ERROR;  // 不合法
    if (L.length >= L.listsize) { // 空间已满，需要扩容
        ElemType *newbase = new ElemType[L.listsize + LISTINCREMENT];
        if (!newbase) exit(OVERFLOW);
        for (int j = 0; j < L.length; j++)
            newbase[j] = L.elem[j];  // 复制原有元素
        delete[] L.elem;
        L.elem = newbase;
        L.listsize += LISTINCREMENT;
    }
    // 移动元素，空出位置
    for (int j = L.length - 1; j >= i - 1; j--)
        L.elem[j + 1] = L.elem[j];
    L.elem[i - 1] = e;
    ++L.length;
    return OK;
}
```
时间复杂度为：`O(Listlength(L))`

**重点：**
假设线性表中包含n个元素，在进行插入操作的时候，若假定在n+1个位置插入元素的可能性均等，则平均移动元素的个数为
$E_{is} = \frac{1}{n+1} \sum_{i=1}^{n+1}(n-i+1) = \frac{n}{2}$
​==平均移动`n/2`个元==素

---

- ` ListDelete(&L,i,&e)` 实现
```cpp
// 删除：删除第 i 个元素，用 e 返回其值
Status ListDelete_Sq(SqList &L, int i, ElemType &e) {
    if (i < 1 || i > L.length) return ERROR;  // 不合法
    e = L.elem[i - 1];
    for (int j = i; j < L.length; j++)
        L.elem[j - 1] = L.elem[j];  // 前移覆盖
    --L.length;
    return OK;
}
```
时间复杂度为：`O(Listlength(L))`

> e的作用是保留被删除的值，方便后续如需使用可以调用

**重点：**
若假定在线性表中的任何一个位置上进行删除的概率都是相等的，则**平均移动元素的个数为**：
$E_{dl} = \frac{1}{n} \sum_{i=1}^{n}(n-i) = \frac{n-1}{2}$

---
### 线性表的优缺点

特点：
- 逻辑顺序与物理顺序一致
- 随机存储

缺点：
- 插入删除操作要移动元素
- 存储空间是预分配的，不灵活，空间浪费
- 表的存储空间难扩充

---
## DS-[[数据结构链表|链表]]

![[Pasted image 20250924112545.png]]

特点：
- 存储空间不一定连续
- 逻辑关系是由指针体现的
- 逻辑上相邻，物理上不一定相连
- 顺序存取，即访问任何一个元素的时间不同

#### 链表的实现

链表由一个又一个节点构成的，节点定义如下：
```cpp
typedef struct node
{
	ElemType data;
	struct node* next;
}LNode,*Linkfirst;
```
>LNode是结构题的别名，`*Linkfirst`是该**指向该结构体的指针类型的别名**。

定义头指针变量：`LinkList H`

##### **初始化链表**

**带头节点**
```
   int InitList (LinkList L)
{
    L=(LNode*) malloc(sizeof(LNode));
    L->next=NULL;
    return OK;
}
   ```

时间复杂度：O(1)


**不带头节点**
```
int InitList (LinkList L)
{
    L=NULL;
    return OK;
}
```

 时间复杂度：O(1)

**区分:头节点和头指针的区别**
- **头指针**:指向链表中**第一个存储数据**的节点
  > 有头节点的链表头指针指向头节点的下一个节点

- **头节点**:为了方便操作在首元结点前设立的节点
  > 所以**头节点不是头指针**



---
##### 链表求长度
一下是单链表求长度的长度
```c
// 2. 求长度
int length_L(LinkList L)
{
    int i=0;
    LinkList p=L->next;
    while(p)
    {
        i++;
        p=p->next;
    }
    return i;
}
```

时间复杂度：O(n)

---
##### 删除节点(不带头节点)
```c
// 删除节点（删除值为val的节点）
void deleteNode(Node** head, int val) {
    Node *p = *head, *pre = NULL;
    while (p != NULL && p->data != val) {
        pre = p;
        p = p->next;
    }
    if (p == NULL) {
        printf("未找到值为 %d 的节点！\n", val);
        return;
    }
    if (pre == NULL) {
        // 删除头指针
        *head = p->next;
    } else {
        pre->next = p->next;
    }
    free(p);
}
```

解释：P代表可能要当前(删除的)节点，Pre表示**P的前驱节点**（要删除的前面的节点）

时间复杂度：O(n)

<mark style="background: #D2B3FFA6;">关键操作: ` pre->next = p->next;`</mark>or: `p->next=p->next->next`


---
##### 添加（插入）节点

```CPP
// 插入节点（在第pos个位置后插入，pos从1开始）
void insertNode(Node* head, int pos, int val) {
    Node* p = head;
    for (int i = 1; i < pos && p != NULL; i++) {
        p = p->next;
    }
    if (p == NULL) {
        printf("插入位置无效！\n");
        return;
    }
    Node* newNode = createNode(val);
    newNode->next = p->next;
    p->next = newNode;
}
```

时间复杂度：O(n)

<mark style="background: #D2B3FFA6;">关键操作: ` newNode->next = p->next; p->next = newNode;`</mark>


---
##### 释放链表和遍历链表

**遍历链表**
```cpp
// 遍历链表
void printList(Node* head) {
    Node* p = head;
    while (p != NULL) {
        printf("%d -> ", p->data);
        p = p->next;
    }
    printf("NULL\n");
}
```

时间复杂度：O(n)


释放链表
```Cpp
// 删除节点（删除值为val的节点）
void deleteNode(Node** head, int val) {
    Node *p = *head, *pre = NULL;
    while (p != NULL && p->data != val) {
        pre = p;
        p = p->next;
    }
    if (p == NULL) {
        printf("未找到值为 %d 的节点！\n", val);
        return;
    }
    if (pre == NULL) {
        // 删除头节点
        *head = p->next;
    } else {
        pre->next = p->next;
    }
    free(p);
}
```

时间复杂度：**O(n)

---
完整代码：
```c
#include <stdio.h>
#include <stdlib.h>

// 定义链表节点
typedef struct Node {
    int data;              // 数据域
    struct Node *next;     // 指针域
} Node;

// 创建新节点
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (!newNode) {
        printf("内存分配失败！\n");
        exit(1);
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// 尾插法创建链表
Node* createListTail(int n) {
    Node *head = NULL, *tail = NULL;
    for (int i = 0; i < n; i++) {
        int val;
        printf("请输入第%d个元素: ", i+1);
        scanf("%d", &val);

        Node* newNode = createNode(val);
        if (head == NULL) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    return head;
}

// 遍历链表
void printList(Node* head) {
    Node* p = head;
    while (p != NULL) {
        printf("%d -> ", p->data);
        p = p->next;
    }
    printf("NULL\n");
}

// 插入节点（在第pos个位置后插入，pos从1开始）
void insertNode(Node* head, int pos, int val) {
    Node* p = head;
    for (int i = 1; i < pos && p != NULL; i++) {
        p = p->next;
    }
    if (p == NULL) {
        printf("插入位置无效！\n");
        return;
    }
    Node* newNode = createNode(val);
    newNode->next = p->next;
    p->next = newNode;
}

// 删除节点（删除值为val的节点）
void deleteNode(Node** head, int val) {
    Node *p = *head, *pre = NULL;
    while (p != NULL && p->data != val) {
        pre = p;
        p = p->next;
    }
    if (p == NULL) {
        printf("未找到值为 %d 的节点！\n", val);
        return;
    }
    if (pre == NULL) {
        // 删除头节点
        *head = p->next;
    } else {
        pre->next = p->next;
    }
    free(p);
}

// 释放链表
void freeList(Node* head) {
    Node* p;
    while (head != NULL) {
        p = head;
        head = head->next;
        free(p);
    }
}

int main() {
    int n;
    printf("请输入链表元素个数: ");
    scanf("%d", &n);

    Node* head = createListTail(n);
    printf("创建的链表: ");
    printList(head);

    // 插入示例
    insertNode(head, 2, 99);
    printf("在第2个节点后插入99: ");
    printList(head);

    // 删除示例
    deleteNode(&head, 99);
    printf("删除值为99的节点: ");
    printList(head);

    freeList(head);
    return 0;
}
```

**链表和线性表操作对比**

| **操作**              | **顺序表** | **链表** |
| --------------------- | ---------- | -------- |
| 按位置插入/删除       | O(n)       | O(n)     |
| **已知位置插入/删除** | O(n)       | **O(1)** |
| 随机访问              | **O(1)**   | O(n)     |

---
## DS-栈和队列

栈：只能在一端进行的(后进先出)
队列：分别在两端进行(先进先出)

### [[栈]]

**栈**是一种**特殊的[[线性表]]**（[[数据元素]]之间的关系是线性关系），其插入，删除**只能在表的一端进行**，另一段固定不动。
- **栈顶**（Top）：插入删除的一端
- **栈底**（Bottom）：固定不动的一端
- **入栈**（Push）：又称压入，即插入一个元素
- 出栈（POP）：又称弹出，即删除一个元素

**栈的逻辑结构**
- 只允许在表的一端进行插入和删除操作。进行插入和删除操作的这一端称为**栈顶**（Top），另一端固定不变，称为**栈底**（Bottom）。
    
- 在**栈顶**插入元素的操作称为**进栈**（或**入栈**，Push）操作，在**栈顶**删除元素的操作称为**出栈**（Pop）操作。
    
- 元素按 a1,a2,a3,…,an 的次序**进栈**，第一个进栈的元素 a1 一定在**栈底**，最后一个进栈的元素 an 一定是**栈顶元素**，第一个出栈的元素也一定是**栈顶元素** an。

具体如图所示：
![[Pasted image 20250927214559.png]]

**特点**：栈的操作顺序有==**“先进后出”或“后进先出”的特点（FILO）**==

#### 栈的基本操作

1. **初始化**：`InitStack(&S)`
   功能：构造一个空栈
2. **销毁栈**：`DestroyStack(&S)`
   功能：销毁一个已存在的栈
3. **置空栈**：`ClearStack(&S)`
   功能：将栈 S 置为空栈
4. **取栈顶元素**：`GetTop(S,&e)`
   功能：取栈顶元素，并用e返回
5. **进栈操作**：`Push(&s,e)`
   功能：栈顶元素退栈，并用e返回
6. **退栈操作**：`Pop(&s,&e)`
   功能：栈顶元素退栈，并用e返回
7. **判空操作**：`StackEmpty(S)`
   功能：若栈S为空，则返回True，否则返回False;

#### 栈的顺序存储结构及实现

存储方式：利用一组连续的内存依次存放自栈底到栈顶的元素
![[Pasted image 20250927220942.png]]

栈内有两个指针：
1. base：指向栈底，若 `base=NULL` 表示结构不存在；`top初始值=base` 为空栈
2. top：**栈顶指针始终指向栈顶元素的*下一个位置***。
   **`top=top-1` 出栈**
   **`top=top+1` 入栈**
![[Pasted image 20250927221801.png]]


-  特点
这种数据结构（例如栈）的特点是：简单、方便，但易产生溢出。
- **上溢（Overflow）**
定义： 栈已经满了，但还要压入元素。
性质（注）： 上溢是一种错误，它会导致问题的处理无法进行下去。
- **下溢（Underflow）**
定义： 栈已经空了，但还要弹出元素。
性质（注）： **==下溢一般被认为是一种结束条件==，即问题处理结束**。

#### 栈的抽象数据类型定义ADT

虚拟实现：
- **顺序栈（SqStack）的结构定义**和**常量宏定义**:

```c
#define STACK_INIT_SIZE 100 // 栈存储空间的初始分配量
#define STACKINCREMENT 10   // 栈存储空间的分配增量

typedef struct {
    SElemType *base;        // 栈空间基址称为栈底指针，指向栈底位置
    SElemType *top;         // 栈顶指针，约定栈顶指针指向栈顶元素的下一个（后面）一个位置
    int stacksize;          // 当前分配的栈空间大小（以 sizeof(SElemType) 为单位）
} SqStack;                  // SqStack：结构类型名
```

定义 `base` 和 `top` 指针和记录栈的空间大小的变量

##### **初始化操作**
`InitStack_Sq(Sqstack &S) `
- 参数：S是存放栈的结构变量
- 功能：建一个空栈S

代码实现：
```C
Status InitStack_Sq(SqStack &S) {
    // 构造一个空栈 S

    S.base = (SElemType *)malloc(STACK_INIT_SIZE * sizeof(SElemType));
    // 为顺序栈动态分配存储空间

    if (!S.base) exit(OVERFLOW); // 存储分配失败

    S.top = S.base;             // 栈顶指针指向栈底（表示空栈）
    S.stacksize = STACK_INIT_SIZE; // 记录当前栈的容量

    return OK;
} // InitStack_Sq
```
> `S.top = S.base` 代表空栈

##### 销毁栈操作

`DestroyStack_Sq(SqStack &S)` 
功能：销毁一个已存在的栈

代码实现：
```C
Status DetroyStack_Sq(SqStack &S)
{
	if(!S.base) return ERROR;  //判断栈是否已经建立
	free(S.base);
	S.base=S.top=NULL;
	S.stacksize=0;
	return OK;
}//SetroyStack_Sq
```


##### 置空栈操作

`ClearStack_Sq(SqStack &S)`
功能：将栈S置为空栈

代码实现：
```C
Status ClearStack_Sq(SqStack &S)
{
	if(!S.base) return ERROR;  //判断栈是否已经建立
	S.top=S.bace;
	return OK;
}// ClearStack_Sq
```

> 与销毁栈操作相比，前者需要释放空间，而后者只需要置为空栈就可以了



##### 取栈顶元素操作

`GetTop_Sq(SqStack S,SElemType &e)`
功能：取栈顶元素，并用e返回

```C
Status GetTop_Sq(SqStack S,SelemType &e)
{
	if(!S.base) return ERROR;  //判断栈是否已经建立
	e=*(S.Top-1);
	return OK;
}//GetTop_Sq
```


##### 进栈操作

`Status Push(SqStack &S,SElemtype e)`
功能：压栈

```C
Status Push(SqStack &S,SElemtype e)
{
	//考虑上溢情况
	if(S.top-S.bace>=S.stacksize)
	{
		//栈满，需要追加存储空间
		S.base=(SElemType*)realloc(S.base,(S.stacksize+STACKINCREMENT)sizeof(Elemtype));
		if(!S.base) exit(OVERFLOW); //判断内存是否分配成功
		S.top=S.base+S.stacksize;//更新top指针的位置
		S.stacksize+=STCKINCREMENT;//更新栈的大小
	}
	
	*S.top++=e //元素e插入栈顶，修改栈顶指针
	reurn OK;
}
```

解释：`	*S.top++=e` =`*S.top=e`+`S.top++`
先把e插入栈顶，然后更新top到下一个位置


##### 出栈操作
 `Pop(SqStack &S,SElemType &e)`
功能：栈顶元素退栈，并用e返回

```c++
Status Pop(SqStack &S,SElemType &e)
{
	//判断是否是空栈
	if(!S.base) return ERROR;
	
	s.top--;//先下移 top 指针
	e=*s.elem[top];//后赋值
	return OK;
}//Pop
```

---
#### 栈的链式表示

[[链栈]]：栈的链接存储表示（用链表存储）。只允许在表头进行插入和删除运算的电链表，其表头指针叫做栈的**栈顶指针**。
	存储方式：
		1. 如果链表尾作为栈顶，则入，出栈操作的时间复杂性为：O(n)
		2. 如果**链表头作为栈顶**，则入，**出栈的时间复杂度为：O(1)**   --->**常用**的形式

栈的链式存储结构如图：
![[Pasted image 20251010194436.png|300]]

- 链式栈的栈顶指针就是链表的头指针
- *进栈操作*：在该线性表的**第一个元素结点之前插入一个新结点**
- *出栈操作*：**删除链表的第一个元素结点**

> 特点：减少溢出，提高空间利用率。


#### 链栈实现


`Lstack`是栈的结构体名称，包含了存储的数据，以及指向下一个数据地址的指针。
```C
typedef struct LNode {
    // 数据域，e 的类型（例如 int, char 等）
    DataType data; 
    
    // 指针域，指向下一个 LNode 结构体（也就是下一个 LStack 节点）
    struct LNode *next; 
} LStack; // 将 struct LNode 类型重命名为 LStack
```

##### 栈的初始化
```c
s = (LStack *) malloc ( sizeof ( LStack ) );//作为头节点
s->next = NULL;
```

时间复杂度：O(1)

##### 入栈
```c
p = (LStack *) malloc ( sizeof ( LStack ) );
if (!p) exit(OVERFLOW);
p -> data = e; //e 是需要存进去的数据
p -> next = s -> next ;
s -> next = p ;//更新栈顶元素为新入栈的p
```

> S表示链表的头指针，无数据

时间复杂度为：O(1)

##### 出栈
> 删除栈顶元素，并用 e 返回其值

```c
if ( s->next = NULL )
    return (OVERFLOW);  //下溢（栈空）
p = s->next;
e = p->data;//存储删除结点的数据
s->next = p->next;
free(p);
```

##### 读取栈顶元素(GetTop)
```c
Status GetTop(LinkList S, ElemType &e)
{
    if (S == NULL) 
        return ERROR; 
    else 
    {
        e = (S->next)->data;
        return OK;
    }
}
```

---
#### <mark style="background: #ADCCFFA6;">顺序表和链表区别</mark>

**顺序栈**需要固定空间长度，存在**溢出问题**，但**链式栈**的每个元素都有指针域，增加了**空间开销**。另外，求链栈的**大小时间复杂度为 O(n)**。

| **比较维度**   | **顺序栈**                                                       | **链栈**                                                    |
| -------------- | ---------------------------------------------------------------- | ----------------------------------------------------------- |
| **内存分配**   | **静态/预分配**。通常需要预先定义一个固定大小的数组。            | **动态分配**。随元素的增加而实时分配内存。                  |
| **时间复杂度** | 进栈和出栈均为 $O(1)$。**但若需扩容，单次进栈可能达到 $O(n)$。** | **进栈和出栈始终为恒定的 $O(1)$**。                         |
| **空间开销**   | **低**。只存储数据本身，但可能存在闲置空间浪费。                 | **高**。每个节点需额外存储指针（如 `next`），占用更多内存。 |



---

### [[队列]]

[[队列]]（[[队列|Queue]]）：是一种特殊的[[线性表]]

队首（front):进行删除的一端
队尾（rear）：进行插入的一端

形式如下图：
![[Pasted image 20251013183309.png]]
出队：在队首删除一个元素
入队：在队尾插入一个元素

**队列的特点**：**==先进先出/后进后出(FIFO)==**
> 可与地铁排队类比，先到的人先出

队列通常设置两个指针变量：
- **头指针**：指示队头元素的位置
- **队尾指针**：指示队尾元素的位置
特殊规定：头指针必须指向队列头元素，尾指针始终指向**队列尾元素的下一位置**

特殊情况下指针的形式：
- **空队列**：`rear=front=0`
- **入队**：`rear=rear+1`
- **出队**：`front=front+1`
- **队列空**：`front=rear`


设置指针的形式：
![[Pasted image 20251013184834.png|200]]

![[Pasted image 20251013185754.png]]

从图中得出：
- **入队**操作（插入元素）总是在**队尾**进行，Q.rear 向后移动。
    
- **出队**操作（删除元素）总是在**队头**进行，Q.front 向后移动。

所以顺序结构（如数组）作为队列的存储形式，会在一系列的入队出队操作后，随着 `Q.front` 和 `Q.rear` 不断向后移动，即使数组前面有空闲空间，如果 `Q.rear` 达到数组末尾，就不能再入队了

特点：简单方便，但是==容易产生**假**溢出==
解决方法：平移数组元素--> 效率低，更好的方法是使用[[循环队列]]。


---


#### 队列的基本操作

- **初始化**操作 `InitQueue(&Q)` 功能：构造一个空队列 Q；
    
- **销毁**操作 `DestroyQueue(&Q)` 功能：销毁已存在队列 Q；
    
- **置空**操作 `ClearQueue(&Q)` 功能：将队列 Q 置为空队列；
    
- **判空**操作 `QueueEmpty(Q)` 功能：若队列 Q 为空，则返回 True，否则返回 False
  
-  **取队头元素**操作 `GetHead(Q,&e)` 功能：取队头元素，并用 e 返回；
    
- **入队**操作 `EnQueue(&Q,e)` 功能：将元素 e 插入 Q 的队尾；
    
- **出队**操作 `DeQueue(&Q,&e)` 功能：若队列不空，则*删除 Q 的队头元素，用 e 返回其值*，并返回 OK，否则返回 ERROR；

#### 队列的结构定义和代码实现

[[队列]]顺序结构定义
```c
// ------ 队列顺序结构的定义 ------
#define MAXQSIZE 100 
typedef struct
{
    QElemType base[MAXQSIZE];  // 静态数组
    int front;                 // 队列头指针
    int rear;                  // 队列尾指针
} SqQueue;
```

队列的简单操作

1. **初始化**：`Q.front = Q.rear = 0` ;
    
2. **入队**：
    
    - `Q.base[Q.rear] = e` ;
        
    - `Q.rear++` ;
        
3. **出队**： `Q.front++` ;
    
4. **判空**： `Q.front == Q.rear` ;
    
5. **求队长**： `Q.rear - Q.front`

---
特殊的，为了解决假溢出的问题，通常使用循环队列的方式解决。接下来详细介绍一下循环队列。
### 循环队列

将顺序队列臆造成一个环状的空间
![[Pasted image 20251013201615.png|450]]
若 `maxsize=12`，那么`rear`最后指向 11，当`rear+1`时，就会指向第 0 个元素


这时候我们需要重现规定队列为空/满的标志了

1.  **设置标志位以区别队列是 “空” “满”**
    
    - 因出队而相等，则为空；
        
    - 因入队而相等，则为满；
        
2.  **少用一个元素的空间，约定**
    
    - rear+1=front 时，就认为队满。


#### 循环队列存储结构和代码实现

循环队列结构定义：
```c
#define MAXQSIZE 100  // 最大队列长度
typedef struct{
    QElemType *base;  // 初始化时动态分配 // 存储空间的基址
    int front;        // 队头指针，指向队头元素
    int rear;         // 队尾指针，指向队尾元素的下一个位置
}SqQueue;
```

不同点：初始化时没有规定数组大小，循环队列是动态的分配


基本操作

##### 初始化操作`InitQuene_Sq(SqQueue &Q)`

参数说明：Q 是存放队列的结构变量
功能：创建一个空队列

```c
Status InitQueue_Sq(SqQueue &Q) { 
    // 构造一个空队列 Q
    Q.base = (QElemType *)malloc(MAXQSIZE * sizeof(QElemType)); 
    if (!Q.base) exit(OVERFLOW); 
    // 存储分配失败
    Q.front = Q.rear = 0; 
    return OK; 
} // InitQueue_Sq
```


##### 入队操作 `EnQueue_Sq(SqQueue &Q,QElemType e)`

入队操作的主要步骤：
1. 检查Q是否已满，若满，返回`ERROR` 
2. 将元素 e 写入队尾
3. 修改队尾指针，使队尾指针指向队尾元素的下一个位置

代码实现：
```c
Status EnQueue_Sq(SqQueue &Q, QElemType e)
{
    //将元素e插入队尾
    // 检查队列是否已满：队尾指针加1后模MAXSIZE等于队头指针，则队列满。
    if ((Q.rear+1)%MAXSIZE == Q.front) 
        return ERROR ; 
    
    // 将元素e插入队尾（Q.rear指向下一个可以插入元素的位置）
    Q.base[Q.rear] = e;
    
    // 修改队尾指针（指向下一个可以插入元素的位置），使用求余运算实现循环
    Q.rear = (Q.rear+1)%MAXSIZE; // <-- 箭头指向“求余运算”
    
    return OK; // 入队成功
} // EnQueue_Sq
```
解释：
- `（Q.rear+1)%MAXSIZE == Q.front`:假设队列已经满了，此时rear已经指向数组最后一位，所以`rear+1` =`MAXSIZX` ,取余的结果就为0。队列没满就是非零。
- `Q.rear = (Q.rear+1)%MAXSIZE;`:取余操作能确保尾指针能在队列满时重置。


##### 出队操作 `DeQueue_SqQueue &Q,QElemType &e)`

出队操作主要步骤：
1. 检查Q是否已满，若满，返回`ERROR` 
2. 将对头元素赋值给 e
3. 修改队头指针，删除队头元素

```c
Status DeQueue_Sq(SqQueue &Q, QElemType &e)
{
    // 删除队头元素，用e返回其值，并返回OK；
    // 否则返回ERROR

    // 检查队列是否为空：队尾指针Q.rear等于队头指针Q.front，则队列空。
    if (Q.rear == Q.front) 
        return ERROR ; 
    
    // 取出队头元素的值，赋给引用参数e
    e = Q.base[Q.front];
    
    // 修改队头指针（指向下一个元素），使用求余运算实现循环
    Q.front = (Q.front + 1) % MAXSIZE; // 修改队头指针
    
    return OK; // 出队成功
} // DnQueue_Sq
```

**循环队列总结**
- **入队指针移动**：`Q.base[Q.rear]=e` ,  ` rear = (rear + 1) % MAXSIZE `
    
- **出队指针移动**：`e=Q.base[Q.rear]` `front = (front + 1) % MAXSIZE`
    
- **计算队列长度**：`Length = (rear - front + MAXSIZE) % MAXSIZE`

---

#### 队列的链式存储结构

存储方式：同一般的线性表相同，由于插入删除操作，需要 `front` , `rear`指针。
链法：
通常使用如下图的链法：`front` 指针指向链头，`rear` 指针指向链尾(最后一个元素)
> `front` 指向头节点,实际上 `front.next` 指向的才是第一个元素


![[Pasted image 20251017104926.png]]

> 为了清理空队列，可以加上头节点

**特点**：没有假溢出，提高了空间利用率

##### 虚拟代码实现

链队列的虚拟实现：
```c
typedef struct QNode { // 链队列节点的类型定义
    QElemType data;    // 用于存放队列元素
    struct QNode *next; // 用于存放元素直接后继
                       // 节点的地址
} QNode, *QueuePtr;

typedef struct { // 链队列的表头结点的类型定义
    QueuePtr front; // 队头指针，指向链表的头结点
    QueuePtr rear;  // 队尾指针，指向队尾结点
} LinkQueue;
```


**初始化操作 `InitQueue_L(LinkQueue &Q)`**

```c
Status InitQueue_L(LinkQueue &Q) {
    //建一个空队列
    Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode)); //为链队列的头结点分配空间

    if (!Q.front) exit(OVERFLOW); // Q.front Q.rear 
    Q.front->next = NULL;
    return OK;
} // InitQueue_L
```



**销毁操作 `DestroyQueue_L(LinkQueue &Q)`**

```c
Status DestroyQueue_L(LinkQueue &Q) {
    //销毁队列Q
    if (!Q.front) return ERROR; // 链队列不存在
    
    // 回收链队列的所有元素结点空间
    while(Q.front->next) { 
        QueuePtr p = Q.front->next; 
        Q.front->next = p->next;
        free(p);
    }
    
    free(Q.front); // 回收队列头结点空间
    Q.front = Q.rear = NULL;
    return OK;
} //DestroyQueue_L
```

`front` 是队头指针（QueuePtr front;）![[Pasted image 20251017111201.png]]



**入队操作 `EnQueue_L(LinkQueue &Q, QElemType e)`**

```c
Status EnQueue_L(LinkQueue &Q, QElemType e) {
    //在链队列Q队尾，插入新的队尾结点
    QNode *p = (QNode *)malloc(sizeof(QNode)); //为新元素e分配结点空间

    if (!p) exit(OVERFLOW); //存储分配失败

    p->data = e;
    p->next = NULL;

    Q.rear->next = p; //修改队尾指针，插入新队尾结点
    Q.rear = p;

    return OK;
}
```
关键操作: `Q.rear->next = p; ` `Q.rear=p`



**出队操作** `DeQueue_L(LinkQueue &Q, QElemType &e)`

若队列不空，则删除Q的队头元素结点，**用e返回其值**，并返回OK；否则返回 `ERROR`

```c
Status DeQueue_L(LinkQueue &Q, QElemType &e) {
    //若队列不空，则删除Q的队头元素结点，用e返回其值，并返回OK；否则返回ERROR

    if (Q.front == Q.rear) return ERROR; 
    //若队列空，返回ERROR

    QNode *p = Q.front->next; // p指向队头元素结点
    e = p->data;

    Q.front->next = p->next; // 修改链队列头结点指针

    if (Q.rear == p) Q.rear = Q.front; 
    // 对于链队只剩一个元素结点的情况，要同时修改队尾指针

    free(p);
    return OK;
}
```
关键操作 `Q.front->next = p->next;`


---

## DS-树和二叉树

### [[树]]

**树的定义**

树是由 n (n≥0) 个节点的有限集合。 如果 n=0，称为**空树**；如果 n>0，则

- 有且仅有一个特定的称之为**根(Root)的节点**，它只有直接后继，但没有直接前驱；（树最顶上的那个结点）
    
- 当 n>1，除根以外的其它节点划分为 m (m>0) 个互不相交的有限集 T1​,T2​,…,Tm​，其中每个集合本身又是一棵树，并且称为根的**子树(SubTree)**。


**基本术语**

- **[[树的节点]]：** 包含一个数据元素及若干指向子树的分支；

- **[[孩子节点]]：** 节点的子树的根称为该节点的**孩子**；

- **[[双亲节点]]：** B节点是A节点的**孩子**，则A节点是B节点的**双亲**；

- **[[兄弟节点]]：** 同一双亲的孩子节点；

- **[[堂兄弟节点]]：** 双亲在同一层的节点互为**堂兄弟**。

- **[[节点的层次]]：** 根节点的层次定义为 1；根的孩子为第二层节点，依次类推。
![[Pasted image 20251018121230.png|250]]
---


- **[[树的高度]]：** 树中节点的最大层次。

- **[[节点的度]]：** 节点子树的个数。

- **[[树的度]]：** 树内各节点的度的最大值。

- **[[叶子节点]]：** 也叫**终端节点**，是度为 0 的节点；（树里面最底下的节点）

- **分支节点：** 度不为 0 的节点；

- **有序树：** 子树有序的树，（子树不能互换）如：家族树；

- **无序树：** 不考虑子树的顺序；

- **节点的层次：** 假设根节点的层次为 1，第 i 层的节点的子树根节点的层次为 i+1。

- **[[树的深度]]：** 树中叶子节点所在的最大层次
>   **树的深度 / 树的高度** = 树中**所有节点最大层次**的值
>   对于单一节点来说
>   - 节点的深度：从**根节点**到该节点的路径长度（层次）
>   - 节点的高度：从该节点到其**最远的叶子节点**的路径长度

---
### 森林

[[森林]]：是 m（m>=0)课互补相交的[[树]]的集合。任何一颗非空树是一个[[二元组]]。

`Tree=(root,F)`      其中：`root`:根节点, `F` ：子树森林

如下图所示：
![[Pasted image 20251018123138.png]]


**[[路径]]：** 树中的 k 个节点 n1​,n2​,…,nk​，满足 ni​ 是 ni+1​ 的双亲，n1​ 到 nk​ 有一条路径。

**[[路径长度]]：** 分支数 = 路径上节点个数 −1

>特别的：根没有双亲，叶子没有孩子
>若 vi 是 vj 的双亲，则 L（vi）=L（vj）-1


**树与线性表特点对比：**

| 特点对比         | 线性结构 (Linear Structure) | 树型结构 (Tree Structure) |
| ---------------- | --------------------------- | ------------------------- |
| **起始元素**     | 第一个数据元素 (无前驱)     | 根结点 (无前驱)           |
| **末尾元素**     | 最后一个数据元素 (无后继)   | 多个叶子结点 (无后继)     |
| **其他数据元素** | 一个前驱、一个后继          | 一个前驱、==多个后继==    |
与线性表的最大区别是树中的元素**会有多个后继**，[[线性表]]只有唯一的后继


### 树的表示

树常见的表示方法

1. 直观表示法：
   ![[Pasted image 20251019154125.png|200]]
2. 集合表示法
   `{a,{b,{e},{f}},{c},{d,{g}}`
3. 文氏图表示法
   ![[Pasted image 20251019154307.png|200]]
4. 目录表示法
   ![[Pasted image 20251019154413.png|200]]
   每个分割代表一层，同一个分格中的元素是同一层的元素
5. *广义表* 表示法
   `(a,(b,(e),(f)),(c),(d,(g)))`

### 树的抽象数据类型定义

通常用 ADT（Abstract Data Type）来定义树的**逻辑结构**和**基本操作**
```c
ADT Tree {
    数据对象：D = { 结点 | 每个结点包含一个数据元素 }
    数据关系：R = { 父子关系 | 除根结点外，每个结点有且仅有一个双亲，根结点没有双亲 }
}
```

- 数据对象 D : 存放节点所记录的数据
- 数据对象 R：记录节点之间的父子关系      e.g. a 是b 的父亲

**树的基本操作：**
```c
基本操作：
        InitTree(&T)              // 初始化一棵空树
        DestroyTree(&T)           // 销毁树，释放内存
        CreateTree(&T, definition)// 按给定定义创建树，definition 给出树 T 的定义
        ClearTree(&T)             // 清空树，使其变为空树
        TreeEmpty(T)              // 判断树是否为空
        TreeDepth(T)              // 返回树的深度
        Root(T)                   // 返回树的根结点
        Parent(T, cur_e)          // 返回结点cur_e的双亲
	    Value(T，Cur_e)           // cur_e 是树 T 中某个节点，返回其值
	    Assign(T,cur_e,value)     // 节点 cur_e 赋值为 value
        LeftChild(T, cur_e)       // 返回结点cur_e的最左（第一个）孩子节点，否则返回空
        RightSibling(T, cur_e)    // 返回结点cur_e的右兄弟,没有则返回空
        InsertChild(&T, p, i, c)  // 插入子树c为结点p的第i个孩子
        DeleteChild(&T, p, i)     // 删除结点p的第i个子树
        TraverseTree(T, visit())  // 遍历树，对每个结点执行visit()
```


### 二叉树

[[二叉树]]：有一个[[根节点]]加上两棵树分别成为左子树和右子树的，互补相交的二叉树组成
>二叉树也可以是空树

如图所示：
![[Pasted image 20251019170859.png]]

[[二叉树]]的特点：
- 二叉树中**不存在度超过 2 的节点**
- 二叉树每两个节点至多有两颗子树，且有左右之分，次序不能颠倒

[[二叉树]]的性质:
- 在二叉树的第 i 层上至多有 $2^{i−1}$ 个结点。(i≥1)
- 深度为 k 的二叉树至多有$2^{k-1}$ 个节点
  > **[[树的深度]]** 是指从 **根结点** 到 **最深的叶子结点** 所经过的 **结点层数**。也就是说   **树的深度 = 树中所有结点的最大层数** 
- 叶子节点数为 n0，度为 2 的节点数为 n2，则 **n0=n2+1**

#### 特殊的二叉树

##### [[满二叉树]]

[[满二叉树]]：一颗深度为 k 且有 $2^{k}-1$ 个节点的[[二叉树]]
>即所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，其特点是每一层上的结点数都是最大结点数。 

满二叉树实例（把所有节点填满）
![[Pasted image 20251019175913.png]]


##### [[完全二叉树]]

[[完全二叉树]]：是一棵二叉树，**除最后一层外，其余各层的结点数都达到最大值**，并且 **最后一层的结点都集中在最左边**，中间不允许有空位。
![[Pasted image 20251019174427.png]]

非完全二叉树例子：
```
        A
       / \
      B   C
     /    / \
    D    E   F
```
原因：没有完全集中在左边

**满二叉树和完全二叉树对比**

| **类型**   | **特点**                       |
| ---------- | ------------------------------ |
| 满二叉树   | 每层都满                       |
| 完全二叉树 | 最后一层可不满，但**从左到右** |
> 完全二叉树不一定是满的



[[完全二叉树]]特点
- 叶子节点只可能出现在最下层和次下层
- 最下层的叶子结点集中在树的左部
- 具有 n 个节点的的完全二叉树，[[树的深度|深度]]为$h = \lfloor \log_2 n \rfloor + 1$ 

特别的：
对一个含有 **n 个节点**的[[完全二叉树]]从上到下且从左到右进行编号
![[Pasted image 20251019194212.png|300]]
对任意一个编号为 i 的节点：
1. i=1 ，则该节点是[[根节点]]，无双亲。
2. i≠1 时（不为根节点）时，`i/2`为该节点的双亲节点。
3. 若`2i>n` 时，该节点没有左孩子，否则 `2i` 为该节点的左孩子节点
4. 若`2i+1>n` 时，该节点没有左孩子，否则 `2i+1` 为该节点的右孩子节点

### 二叉树的存储结构

#### 二叉树的顺序存储结构

二叉树可以使用顺序存储结构的形式存储[[完全二叉树]]。存储形式为：用一组连续的存储单元**按照[[完全二叉树]]的每个节点编号**顺序存放节点内容。

使用一维数组存储[[完全二叉树]]时，对于[[树的深度|深度]]为 k 的[[完全二叉树]]来说需要分配$2^k-1$大小的空间。



e.g
![[Pasted image 20251222102420.png]]
> 空缺的节点用 `0` 填充



最坏情况：
当存储的树为单支树的情况下，深度为 k 的且只有 k 个节点的单支树，需要$2^k-1$ 的一维数组。-->[[单支树|浪费情况解释]]

缺点：对于非完全二叉树，需要将填补空缺位置。若空缺节点过多，会造成空间利用率下降。

#### 二叉树的链式存储结构

若使用[[#二叉树的顺序存储结构]]方式存储造成空间浪费的话，应该考虑使用链式存储结构。

以下是几种使用链式存储表示的二叉树：

##### 二叉链表
![[Pasted image 20251019203338.png|500]]


[[二叉链表]]的定义如下
```c
typedef struct BiTNode{
    TElemType data;
    struct BiTNode *Lchild;
    struct BiTNode *Rchild;
}BTNode, *BTree;
```

解释：`Lchile` 和`Rchile` 分别指向了该节点的左，右指针。`data`是数据元素。

[[二叉链表]]的存储结构特点：**寻找孩子节点容易**，寻找双亲比较困难。

若需要频繁寻找双亲，建议使用[[三叉链表]]

---
##### 三叉链表
![[Pasted image 20251019204358.png|500]]

在[[二叉链表]]的基础上多加了`parent` 指针记录双亲节点。

[[三叉链表]]定义如下：
```c
typedef struct TriTNode { // 节点结构
    TElemType data;
    struct TriTNode *lchild, *rchild; // 左右孩子指针
    struct TriTNode *parent; // 双亲指针
}TriTNode, *TriTree;
```

---
三者关系图例：
![[Pasted image 20251019204716.png|500]]



---
### 二叉树的遍历

遍历即**每个节点都被访问**一次，而且**只能被访问一次。**

二叉树遍历的方法：
1. [[先序遍历]]
2. [[中序遍历]]
3. [[后序遍历]]

一颗[[二叉树]]由[[根节点|根]]，[[左子树]]，[[右子树]]三部分组成。[[二叉树]]的遍历可以分解为：访问[[根节点|根]]，遍历[[左子树]]，遍历[[右子树]]

>本质上[[二叉树]]的遍历算法都是[[递归]]操作，重复根据原理一层一层递归遍历
>> 递归定义包括两部分:基本项，递归项


### 遍历算法的应用

 #### 统计二叉树的叶子结点个数
 
 在[[#二叉树的遍历|遍历]]的过程中查找叶子节点，并计数。（把访问节点换成了计数）
代码实现如下：
```c
void CountLeaf (BiTree T, int& count){
    if (T) {
        if ((!T->lchild)&&(!T->rchild))
            count++;    // 对叶子节点计数
        CountLeaf( T->lchild, count);
        CountLeaf( T->rchild, count);
    } // if
} // CountLeaf
```


#### 求二叉树的深度([[后序遍历]])

> 深度的定义是左，右子树深度的最大值加 1

基本思路：求的左，右子树的深度的最大值，然后加1
``` c
int Depth (BiTree T) { // 返回二叉树的深度
    int depthval; // 用于存储深度值的变量
    if (!T) {
        depthval = 0;
    } else {
        int depthLeft = Depth(T->lchild);
        int depthRight = Depth(T->rchild);
        
        // 节点的深度 = 1 + 左子树深度和右子树深度中的较大者,1 是表示根节点深度为 1
        depthval = 1 + (depthLeft > depthRight ? depthLeft : depthRight);
    }
    return depthval;
}
```

---
### 由二叉树的先序和中序序列建树

已知：
- [[先序遍历]]：根-->左子树-->右子树
- [[中序遍历]]：左子树-->根-->右子树

```c
void CreateBT(BiTree *T, const char pre[], const char ino[],
              int ps, int is, int n) {
    // === 1. 递归终止条件 ===
    if (n == 0) {
        *T = NULL;
        return;
    }

    // === 2. 查找根节点在中序序列中的位置 ===
    int k = Search(ino, pre[ps]);
    if (k == -1) {
        *T = NULL; // 异常情况
        return;
    }

    // === 3. 创建根节点 ===
    *T = (BiTNode *)malloc(sizeof(BiTNode));
    (*T)->data = pre[ps];

    // 左子树节点数
    int left_len = k - is;

    // === 4. 构造左子树 ===
    if (left_len > 0)
        CreateBT(&((*T)->lchild), pre, ino, ps + 1, is, left_len);
    else
        (*T)->lchild = NULL;

    // === 5. 构造右子树 ===
    int right_len = n - left_len - 1;
    if (right_len > 0)
       CrtBT(T->rchild, pre, ino,
      ps + 1 + left_len,  // 右子树在先序序列的起点，加一是跨过根节点
      k + 1,              // 右子树在中序序列的起点
      n - left_len - 1);  // 右子树节点数
    else
        (*T)->rchild = NULL;
}
```

参数说明：

|         |                          |
| ------- | ------------------------ |
| `pre[]` | 先序遍历序列数组         |
| `ino[]` | 中序遍历序列数组         |
| `ps`    | 当前先序子序列的起始下标 |
| `is`    | 当前中序子序列的起始下标 |
| `n`     | 当前子树的节点总数       |

我们可以由[[中序遍历|中序]]序列和[[先序遍历|先序]]（[[后序遍历|后序]]）序列得到二叉树（但是[[先序遍历|先序]]和[[后序遍历|后序]]不能得到）

e.g.
![[IMG_0153.jpeg]]
 

### 线索二叉树

[[线索二叉树]]对比普通二叉树减少了开销，改进存储结构。

**核心思想**
- 如果某节点左指针为空，就让它指向**该节点的中序前驱**
- 如果右指针为空，就让它指向**该节点的中序后驱**

> **- 中序前驱**：该节点在[[中序遍历|中序]]序列的前一位
> **- 中序后驱**：该节点在[[中序遍历|中序]]序列的后一位


#### 线索二叉树的结构定义

需要区分指针到底是“孩子”还是“线索”，我们要多加两个标志位：
```c
typedef enum{link, thread} PointerTag;  //枚举类型
// link=0，孩子指针, thread=1 前驱/后继的线索

typedef struct BiThrNode{
    TElemType data;
    struct BiThrNode *lchild, *rchild;
    // 左右指针域
    PointerTag Ltag, Rtag; // 左右标志域
} BiThrNode, *BiThrTree;
```

规定：
- 节点左子树不空，`Lchild` 域的指针指向其左子树，且左标志域的值为“指针 Link”
- 节点左子树为空，`child` 域的指针指向其“前驱”，且左标志域的值为“线索 Thread”
> 右子树定义也是如此


为了简化遍历算法，给[[线索二叉树]]链表加上*头节点*，规定如下：
- 头节点的`lchild`域：存放线索链表的**根节点指针**
- 头节点的`rchild`域：存放线索链表的**最后一个节点指针**
- 中序序列第一个节点`lchild`域指向头指针
- 中序序列最后一个节点`rchild`域指向头指针
![[Pasted image 20251027193559.png]]



##### 代码实现
线索链表的遍历：

**核心思想**：
中序遍历的顺序是：**左子树 → 根结点 → 右子树**。在线索化二叉树中，一个结点的中序后继结点可以通过两种方式找到：
1. **左标志为 Link 的情况：** 结点的右子树的**最左下角**结点。
2. **左标志为 Thread 的情况：** 结点的 `rchild` 指针（即后继线索）直接指向后继结点。
利用这两种情况连续移动 p 指针


```c
void InOrderTraverse_Thr(BiThrTree T, void (*Visit)(TElemType e)) {
	//T 为头节点
    BiThrTree p = T->lchild; 
    
    while (p != T) { 
        // 1. 查找中序第一个结点
        while (p->LTag == Link) {
            p = p->lchild;
        } 

        // 2. 访问当前结点
        if (!Visit(p->data)) {
            return ERROR;
        }

        // 3. 沿线索访问所有后继结点
        while (p->RTag == Thread && p->rchild != T) {
            p = p->rchild;
            Visit(p->data);
        }
        
        // 4. 进入右子树或结束遍历
        p = p->rchild;
    }
}
```


[[建立一棵中序线索化二叉树算法]]
[[中序遍历进行中序线索化]]
[[中序线索二叉树中找结点后继节点算法]]
[[中序线索二叉树中找结点前驱节点算法]]

---

### 树的存储结构


#### [[双亲表示法]]

双亲表示法的核心是：

> **每个节点只记录它的双亲（父节点）的位置（下标）。**

e.g.
现在有这样一棵树：
```
        A
      / | \
     B  C  D
       / \
      E   F
```

对应的**双亲表示表**如下：

| **下标(i)** | **数据(data)** | **双亲(parent)** |
| ----------- | -------------- | ---------------- |
| 0           | A              | -1（根节点）     |
| 1           | B              | 0                |
| 2           | C              | 0                |
| 3           | D              | 0                |
| 4           | E              | 2                |
| 5           | F              | 2                |
> 根节点的双亲为 `-1` 

**特点**：
- 便于涉及双亲的操作
- 求节点的孩子时需要遍历整棵树


树的定义：
```c
#define MaxSize 100 // 最大结点个数
typedef char TreeData; // 结点数据类型定义
// 树结点定义
typedef struct {
    TreeData data;  // 存储结点的数据
    int parent;     // 存储该结点双亲（父结点）在数组中的位置（下标/索引）
} TreeNode;
// 树的存储结构定义（数组）
typedef TreeNode Tree[MaxSize]; // Tree 是一个包含 MaxSize 个 TreeNode 元素的数组类型
```

#### [[孩子表示法]]

孩子表示法：通过保存每个节点的孩子节点的位置，表示书中节点之间的结构关系。

**顺序存储**
定义：
```c
#define MAX_TREE_SIZE 100

// 结点定义：度限制为 d 的树结点
typedef struct PTNode {
    TElemType data; // 存储结点的数据
    
    // 孩子位置域（存储 d 个孩子在数组中的位置/下标）
    int child1;     // 第 1 个孩子位置域
    int child2;     // 第 2 个孩子位置域
    // ...
    int childd;     // 第 d 个孩子位置域
} PTNode;

// 树的整体结构定义
typedef struct {
    PTNode nodes[MAX_TREE_SIZE]; // 结点数组
    int n;                       // 树中结点的实际数量
} PTree;
```
![[Pasted image 20251027205611.png]]


**孩子表示法链式存储**

在**孩子链表表示法**中：

> 每个节点都用一个结构体存储自己的数据，同时保存一个**指向其第一个孩子节点的链表指针**。

每个节点都有一个这样的指针
```c
ChildNode *firstChild;
```

> 作用是：> **指向这个节点的“第一个孩子”的链表结点**。

e.g.
```
        A
      / | \
     B  C  D
       / \
      E   F
```

表示：
以 A 为举例
```
A
| firstChild
↓
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
| child: B     | →→→ | child: C     | →→→ | child: D     |
| next:  *---- |     | next:  *---- |     | next: NULL   |
└──────────────┘     └──────────────┘     └──────────────┘

```


结构体定义
```c
// 节点中孩子链表中的结点定义 (用于链接兄弟结点)
typedef struct CTNode {
    int child;                // 孩子结点在主数组中的位置（下标/索引）
    struct CTNode * next;     // 指向下一个孩子结点
}* ChildPtr; // ChildPtr 是指向 CTNode 结构的指针类型别名
--------------------------------------------------------------------
// 树结点在主数组中的定义（称为表头结点）
typedef struct {
    TElemType data;             // 存储结点的数据
    ChildPtr firstchild;        // 指向该结点的第一个孩子的孩子链表的头指针
} CTBox;
--------------------------------------------------------------------
// 树的整体存储结构定义
typedef struct {
    CTBox nodes[MAX_TREE_SIZE]; // 包含所有树结点的数组
    int n;                      // 树中结点的实际数量
    int r;                      // 根结点在数组中的位置（下标/索引）
} CTree;
```


#### 孩子兄弟表示法

[[孩子兄弟表示法]]只保留两个指针，记录*第一个孩子*和*第一个右兄弟*的指针
- **firstchild（第一个孩子指针）**：指向该结点的第一个孩子
- **nextsibling（右兄弟指针）**：指向该结点的下一个兄弟。

节节点结构定义：
```c
typedef struct CSNode {
    ELemType data;                 // 结点数据
    struct CSNode *firstchild; // 指向第一个孩子
    struct CSNode *nextsibling;// 指向右兄弟
} CSNode, *CSTree;
```

---
### 树与二叉树的转换

#### [[树转换成二叉树]]

转换规则：
假设树中每个结点的孩子按从左到右排列。

对于树中的每个结点：

1. **保留它的第一个孩子** → 作为该结点在二叉树中的 **左孩子**。
    
2. **保留它的右边兄弟** → 作为该结点在二叉树中的 **右孩子**。
    
3. 其余孩子（除了第一个）通过“兄弟链”串起来。

> 省流：==**左孩子右兄弟**==


e.g.
一棵树定义为：
```
        A
      / | \
     B  C  D
       / \
      E   F
```

转化为二叉树：
```
        A
       /
      B
       \
        C
       / \
      E   D
       \
        F
```


由此，接下来输得各种操作都是由二叉树的操作来完成。此时，树的左右子树概念变成：==**左是孩子，右是兄弟**==


#### [[二叉树转换成树]]

转换过程：
- **加线**：节点 P 为双亲节点的左孩子，那么将 p 的右孩子（兄弟），右孩子的右孩子……都与 p 的双亲节点相连
- **拆线**：把原本二叉树中的双亲与**右**孩子之间的连线
- **调整**：~~整成好看的树~~

![[Pasted image 20251030090342.png|450]]


#### 森林转成二叉树

转换规则：
- 将每棵树分别[[#树转换成二叉树|转换成二叉树]]
- 将每棵树的根节点用线相连
- 以第一颗树根节点为二叉树的根，然后以根节点为轴线顺时针旋转，构成二叉树。

e.g.
![[Pasted image 20251030090832.png|450]]


#### 二叉树转化成森林

转换步骤：
- **拆线**：将二叉树中根节点和其右节点的连线，以及右节点的右节点（以及接下来相连的所有右节点）拆掉。拆分后成为一颗颗孤立的二叉树
- **还原**：把每颗孤立的二叉树[[#二叉树转换成树|还原成树]]

---
### 树和森林遍历

森林（树）的遍历方法：先把森林（树）[[#树转换成二叉树]]/[[#森林转成二叉树]] ，然后再按二叉树的[[#二叉树的遍历]]规则遍历。

#### 树的遍历

树的遍历通常只有这几种：

1. **先根遍历（Preorder）**：访问根 → 遍历每个子树
2. **后根遍历（Postorder）**：遍历每个子树 → 最后访问根
3. **层次遍历（Level order）**：从上到下、从左到右一层层访问

e.g
```
        A
      / | \
     B  C  D
       / \
      E   F
```

- **先根遍历**：A B C E F D
- **后根遍历**：B E F C D A 
- **层次遍历**：A B C D E F

> **树没有中序遍历**：无法知道哪里是“中”


#### 森林遍历

森林的遍历可以分为两类：

| **类型**                  | **定义**                                                     |
| ------------------------- | ------------------------------------------------------------ |
| **先序遍历（Preorder）**  | 按照每棵树的**先根遍历顺序**进行，树与树之间按从左到右的顺序 |
| **后序遍历（Postorder）** | 按照每棵树的**后根遍历顺序**进行，树与树之间按从左到右的顺序 |

#### 树的应用

树的存储结构为[[孩子兄弟表示法|孩子兄弟]]链表
```c
typedef struct CSNode{
    Elem data;
    struct CSNode *firstchild, *nextsibling;
} CSNode, *CSTree;
```

##### 求树的深度

```c
int TreeDepth(CSTree T) {
    if (!T) return 0;
    int childDepth = TreeDepth(T->firstchild);
    int siblingDepth = TreeDepth(T->nextsibling);
    // 当前节点的深度 = 子树深度 + 1
    // 兄弟节点的深度不叠加，但要比较
    return (childDepth + 1 > siblingDepth ? childDepth + 1 : siblingDepth);
}
```



##### 输出所有根节点到叶子的路径

使用递归和[[栈]]实现算法
```c
void AllPath( Bitree T, Stack& S )
// 输出二叉树上从根到所有叶子节点的路径
{
    if (T) {
        // 1. 节点入栈（将当前节点的数据加入到当前路径中）
        Push(S, T->data);

        // 2. 判断是否为叶子节点
        if (!T->Lchild && !T->Rchild) 
            PrintStack(S); // 输出路径
        
        // 3. 递归遍历左右子树
        else { 
            AllPath(T->Lchild, S);
            AllPath(T->Rchild, S);
        }

        // 4. 节点出栈（以该节点为根的路径求完，退出）
        Pop(S); 
    } 
} // AllPath
```

---
### 哈夫曼树与哈夫曼编码

#### 最优树

前置概念：
- [[节点的路径长度]]：从根节点到该节点的路径上分支的数目
- [[树的路径长度]]：树中每个节点的路径长度之和

[[树的带权路径长度]]：树的每个叶子节点所带的权值 wi 与该节点到根节点的路径长度 li 的乘积之和
公式：$$WPL = \sum_{k=1}^{n} w_k l_k$$
其中：
- n：叶子节点的个数
- wk：第 k 个叶子结点的权值
- lk：第 k 个叶子结点到根节点的路径长度

e.g.
![[Pasted image 20251102005805.png|400]]


**[[最优二叉树]]**（**赫夫曼树**）：[[树的带权路径长度]]WPL 最小的二叉树


#### 构建赫夫曼树

步骤：
1. 每个字符作为叶节点，节点权值 = 该字符频率（或权重）。
2. 将所有节点放入**最小堆**（优先队列，按权值升序）。
3. 取出权值最小的两个节点作为左右子节点，合并成新节点，其权值为两者之和，将新节点放回堆中。
4. 重复 3，直到堆中只剩一个节点，该节点为根，得到 Huffman 树。
5. 从根到各叶子的路径：约定“左分支 = 0，右分支 = 1”，得到各字符的二进制前缀码（Huffman 编码）。

![[Pasted image 20251102010919.png|500]]

---
#### 赫夫曼编码

约定：
- 树中的==左分支==表示字符 ‘0’
- 树中的==右分支==表示字符 ‘1’
e.g.
![[Pasted image 20251102011432.png|300]]

#### 赫夫曼树和赫夫曼编码存储表示

使用一个**数组**来存储哈夫曼树的所有节点（包括叶子节点和内部节点）。`HuffmanTree` 实际上是一个指向这个数组起点的指针。
```c
// 定义哈夫曼树节点结构
typedef struct 
{
    unsigned int weight;    // 权（用于构建哈夫曼树）
    unsigned int parent;    // 父节点的索引
    unsigned int lchild;    // 左子节点的索引
    unsigned int rchild;    // 右子节点的索引
} HTNode, *HuffmanTree;      // HTNode 是结构体类型名，*HuffmanTree 是指向结构体的指针类型别名
// 备注：HuffmanTree 类型通常用于动态分配数组来存储整个哈夫曼树

// 定义哈夫曼编码类型别名
typedef char **HuffmanCode; // HuffmanCode 是一个指向指针的指针类型别名
```

- `Huffmancode` 是代表一个**字符指针的数组**，它用于存储所有字符的哈夫曼编码（每个编码是一个字符串）。
  > 数组每个元素都是一个`char*`类型的指针，是每个节点的赫夫曼编码
  
  
- 数组中的索引值（如 `parent`, `lchild`, `rchild`）被用来表示节点之间的连接关系。
  >parent、lchild、rchild 存储的索引是 `HuffmanTree` 数组的索引。

总结：

| **类型别名**  | **基础类型**                | **存储内容**                   | **索引意义**                               |
| ------------- | --------------------------- | ------------------------------ | ------------------------------------------ |
| `HuffmanTree` | `HTNode *` (指向结构体数组) | 整个哈夫曼树的所有节点信息。   | 节点在数组中的位置。                       |
| `HuffmanCode` | `char **` (指向指针数组)    | 所有原始字符的最终编码字符串。 | 通常是原始字符的 $\text{ASCII}$ 码或编号。 |

---
#### [[赫夫曼编码算法]]

构造赫夫曼树核心思想是[[贪心策略]] 
> 即每一步**选择当前看起来最优（局部最优）**的操作

- 叶子节点是需要编码的原始字符
- 内部字符为构建过程中产生的节点
> 赫夫曼编码最长有 n-1 个

```c
void HuffmanCoding(HuffmanTree *HT, HuffmanCode *HC, int *w, int n)  //n ：叶子节点数，*w：字符的权重数组
{
    if (n <= 1) return; 

    int m = 2 * n - 1; // 总结点数

    // 1. 初始化赫夫曼树数组 HT
    *HT = (HuffmanTree)malloc((m + 1) * sizeof(HTNode));// 存储树的所有节点，索引1 到 m
    if (*HT == NULL) return;

    HuffmanTree p = *HT + 1;
    int i;

    // 初始化前 n 个叶子节点
    for (i = 1; i <= n; ++i, ++p) {
        p->weight = w[i];
        p->parent = p->lchild = p->rchild = 0;
    }
    
    // 初始化后 n-1 个非叶子节点
    for (; i <= m; ++i, ++p) {
        p->weight = 0;
        p->parent = p->lchild = p->rchild = 0;
    }
    
//--------------------------------------------------

    // 2. 构建赫夫曼树
    //每次循环都创建一个新的内部节点 i
    for (i = n + 1; i <= m; ++i) { 
        int s1, s2;
        select(*HT, i, &s1, &s2); // 求权值最小的两个结点 s1, s2

        (*HT)[s1].parent = i;
        (*HT)[s2].parent = i;
        (*HT)[i].lchild = s1;
        (*HT)[i].rchild = s2;
        (*HT)[i].weight = (*HT)[s1].weight + (*HT)[s2].weight; 
    }
    
//--------------------------------------------------
    // 3. 生成赫夫曼编码
    *HC = (HuffmanCode)malloc((n + 1) * sizeof(char *));//存储编码的指针数组分配内存
    if (*HC == NULL) return;

    char *cd = (char *)malloc(n * sizeof(char));//临时数组，用于在生成过程中临时存储编码（0到n-1）
    if (cd == NULL) return;
    
    cd[n - 1] = '\0'; // 编码结束符

    // 逐个叶子节点（字符）逆向求编码
    for (i = 1; i <= n; ++i) { 
        int start = n - 1; 
        int c = i; //该节点的索引        
        int f = (*HT)[i].parent; //记录父节点的索引

        // 从叶子向上走到根节点，根节点 parent=0
        for ( ; f != 0; c = f, f = (*HT)[f].parent) {
            
            // 判断是左孩子 ('0') 还是右孩子 ('1')
            if ((*HT)[f].lchild == c) {
                cd[--start] = '0'; 
            } else { 
                cd[--start] = '1'; 
            }
        }
        
        // 为 HC[i] 分配空间并复制编码
        (*HC)[i] = (char *)malloc((n - start) * sizeof(char));//n-start=(n−1)−start+1，1 是结束符
        strcpy((*HC)[i], &cd[start]);
    }
    
    free(cd);
}
```

总结：
算法中使用的数组及其作用;

| **序号** | **数组标识符** | **类型**                     | **存储内容**               | **作用**                                                                     |
| -------- | -------------- | ---------------------------- | -------------------------- | ---------------------------------------------------------------------------- |
| **1**    | `w`            | `int *`                      | **原始权重数组**（输入）。 | 存储每个字符的初始频率或权值，用于初始化叶子节点。                           |
| **2**    | `*HT`          | `HuffmanTree` (即 `HTNode*`) | **赫夫曼树数组**。         | 存储树的所有节点（包括父节点、子节点和权重信息），用于构建树结构。           |
| **3**    | `*HC`          | `HuffmanCode` (即 `char**`)  | **赫夫曼编码指针数组**。   | 存储 $n$ 个字符的最终编码字符串的**起始地址**。                              |
| **4**    | `cd`           | `char *`                     | **临时编码数组**。         | 临时的字符数组，用于在从叶子节点到根节点逆向求编码时，暂存生成的编码字符串。 |

---

## DS-图论

### 基本概念

图：由顶点集合及顶点间的关系集合组成的一种数据结构。
**Graph=(V,E)**

- **V（顶点集合 - Vertex Set）**：
    - 定义：V={x∣x∈某个数据对象}
    - 特性：它是**顶点的有穷非空集合**。
        
- **E（边集合 - Edge Set）**：
    - 定义：它表示顶点之间的关系，是一个**有穷集合**，也叫做**边（edge）集合**。
    - 关系集合 E 可以是以下两种形式之一：
        - **E1 (无向图的边)**：E1={(x,y)∣x,y∈V}
            - 表示顶点 x 和 y 之间存在**无方向**的关系（边）。
                
        - **E2 (有向图的边)**：E2={<x,y>∣x,y∈V∧Path(x,y)}
            - 表示顶点 x 和 y 之间存在**有方向**的关系（路径）。

##### 有向图和无向图
- [[有向图]]：有向图 G 由集合 V(G) 和 E(G) 组成。其中V(G)为顶点集合，E(G)是**有向边**的有限集合，记为`<v,w`,v，w 为顶点，v为弧尾，w为弧头(v-->w)
- [[无向图]]：有向图 G 由集合 V(G) 和 E(G) 组成。其中V(G)为顶点集合，E(G)是边的有限集合，边是顶点的无序对（v，w）=（w，v）
> [[无向图]]：边没有指向
> [[有向图]]：边有指向
- [[混合图]]：在 图 G 中，既有无向边也有有向边

e.g.
![[Pasted image 20251103085134.png|400]]

- [[完全图]]
  - [[无向完全图]]：若有 n 个顶点的无向图有 **n(n-1)/2** 条边
  - [[有向完全图]]：若有 n 个顶点的无向图有 **n(n-1)** 条边
- [[邻接顶点]]：如果 (u,v) 是图 G 的边集 E(G) 中的一条边，则称顶点 u 与顶点 v 互为**邻接顶点**。
  >邻接顶点就是**同一条边的两个端点**。
  
  - [[关联边]]：若边 e=(v,u)，则称边 e 和顶点 v、顶点 u **相关联**。
    >边连接的顶点就与这条边**关联**。
    
    - [[子图]]：设有图 G=(V,E) 和图 G′=(V′,E′)。若满足条件 V′⊆V 且 E′⊆E，则称图 G′ 是图 G 的**子图**。
- [[权]]：某些图的边具有与它相关的数，称之为**权**。

##### 顶点的度
- 无向图中，顶点的度为与该顶点项链的变数
- [[有向图]]中，顶点的度分成入度与出度
  - 出度：以顶点为弧尾的弧的数目（指出去的边）
  - 入读：以顶点为弧头的弧的数目（被指进去）
    >顶点的度(TD)=出度(OD)+入度(ID)


##### 路径长度（Path Length）

路径长度的定义取决于图是否带有**权（Weight）**：

- **非带权图（Unweighted Graph）：** 路径长度是指此路径上**边的条数**。
    
- **带权图（Weighted Graph）：** 路径长度是指路径上**各边的权值之和**。
    

2. 简单路径（Simple Path）

- **定义：** 若路径上的**各顶点** v1​,v2​,…,vm​ **均不互相重复**，则称这样的路径为**简单路径**。
- **简单理解：** 不经过任何重复顶点的路径。
    

3. 简单回路（Simple Cycle）--->环路
- **定义：** 若路径上**第一个顶点** v1​ 与**最后一个顶点** vm​ **重合**，则称这样的路径为**回路（Cycle）**或**环**。
- **简单理解：** 路径的起点和终点是同一个顶点的路径，也叫**环路**。

![[Pasted image 20251103095012.png|500]]

##### 连通图和连通分量

- 在[[无向图]]，若顶点 v1 到 v2 有路径，则 v1 和 v2 是连通的
- [[连通图]]：图中**所有顶点都是连通的**

##### 强连通图

- [[强连通图]]：在有向图中，若对于每一对顶点 vi 和 vj，都存在一条从vi到vj和从vj到vi的路径。
  >每个顶点都有来有回
  

##### 生成树

在图论中，一个**无向[[连通图]]（所有点都是连通的)** G 的**生成树** T 是它的一个**子图**，它必须满足以下两个条件：

- **包含所有顶点：** T 包含了原图 G 的**全部顶点**（Vertex Set VT​=VG​）。
- **边数最少且连通：** T 是一个**连通**的子图，且其**边数最少**，因此它**不包含任何回路或环**。

性质：
- **边数：** 恰好有 n−1 条边。
- **连通性：** 移去 T 中的任何一条边，T 就会变成不连通的。
- **环：** 在 T 中添加任何一条 G 中存在但 T 中不存在的边，都会在 T 中形成一个唯一的**回路（环）**。

##### 有向树和生成森林

- [[有向树]]：顶点的入度为 0，其余顶点的入度为 1
- [[生成森林]]：**生成森林（Spanning Forest） = 若干个[[生成树]]的集合。**

---
### 图的存储结构

设 G=<V, E>是图, V={v1,v2,v3, … vn },设顶点的的角标为它的编号

#### 邻接矩阵
n设图 A = (V, E)是一个有 n 个顶点的图, 图的邻接矩阵是一个二维数组 `A.edge[n][n]`，定义(满足如下条件的n阶矩阵)：
`A.Edge[i][j]`:
1. vi和 vj 连通-->1
2. 不连通-->0

![[Pasted image 20251103105214.png]]
- 无向图的邻接矩阵是对称的
- 有向图的邻接矩阵可能是不对称的

特点：
1. 若图的顶点数为 n，G 占用存储空间为 $n+n^2$  
2. 判断 u，v 是否连通只需要判断二维数组对应的分量是否为 1

顶点使用**一维数组**存储，[[邻接矩阵]]使用**二维数组**存储

#### 邻接矩阵

结构定. ：

前提条件:
```c
#define INFINITY INT_MAX
#define MAX_VERTEX_NUM 20
typedef. enum {DG, DN, UDG, UDN}GraphKind; //定义了一个枚举类型 `GraphKind`，用于表示图的四种不同类型。
//有向图, 有向网, 无向图, 无向网
```

**弧的结构定义**
```c
typedef struct ArcCell { // 弧的定义
    VRType adj;
    // VRType是顶点关系类型，对无权图，用1或0表示相邻否；
    // 对带权图，则为权值类型。
    InfoType *info; // 该弧相关信息的指针
} ArcCell, AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
```

**图的结构定义**
```c  
// 定义图的整体结构
typedef struct { // 图的定义
    VertexType vexs[MAX_VERTEX_NUM]; // 顶点信息
    AdjMatrix arcs; // 弧的信息 (即邻接矩阵)
    int vexnum, arcnum; // 顶点数, 弧数
    GraphKind kind; // 图的种类标志
} MGraph;
```
图的标志：
1. `DG`:有向图
2. `DN`：有向网
3. `UDG`：无向图
4. `UDN`：无向网


![[Pasted image 20251103110947.png|500]]

---
#### [[邻接表]]
图的一种链式存储结构
> 存放所有与这个点相连的所有点的链表

**结构定义**
- 弧的结点结构：
	- `adjvex`:该弧指向的顶点位置
	- `nextarc`:指向下一条弧指针
	- `info`:该弧相关信息的指针
	  
- 顶点的节点结构
	- `data`：顶点信息
	- `firstarc`：指向第一条依附该顶点的弧

e.g.
![[Pasted image 20251103154506.png|500]]

>都记录该节点相连的节点,如 A（0） 与 B（1），D(3)相连


在无向图,若有 n 个顶点和 e 条边,**需要存储空间为 n+2e**
> 每个边节点在单链表中都会出现两次



**邻接表特点**
- **无向图**中顶点 Vi​ 的**度**为第 i 个单链表中的**结点数**。
- **有向图**中
    - 顶点 Vi​ 的**出度**为第 i 个单链表中的**结点个数**。
    - 顶点 Vi​ 的**入度**为整个单链表中邻接点域值是 i 的结点个数（以 Vi​ 为弧头）。

#### [[逆邻接表]]
对每个顶点 vi 建立一个所有以顶点 vi 为弧头的弧的链表(所有指向 vi 的节点)
>邻接表是所有vi 指向的节点


![[Pasted image 20251103161317.png|450]]

**逆邻接表**容易找到指向该顶点的节点,**容易求入度**
> 邻接表容易求出度


##### 邻接表的存储结构

**弧(边)的节点结构**( `ArcNode` 组成边链表的节点)
```
typedef struct ArcNode {
    int adjvex;                 // 该弧所指向的顶点的位置（索引）
    struct ArcNode *nextarc;    // 指向从同一顶点出发的下一条弧的指针
    InfoType *info;             // 该弧相关信息的指针（例如：权值）
} ArcNode;
```


**顶点的节点结构**(`VNode`:组成顶点表的元素)
```
typedef struct VNode {
    VertexType data;    // 顶点信息
    ArcNode *firstarc;  // 指向第一条依附该顶点的弧的指针
} VNode, AdjList[MAX_VERTEX_NUM]; // AdjList 是 VNode 结构体数组的别名
```


**图的结构定义**(`ALGraph`)
```
typedef struct {
    AdjList vertices;           // 头结点向量（即顶点数组，包含所有VNode）
    int vexnum, arcnum;         // 图的当前顶点数和弧数
    int kind;                   // 图的种类（例如：0-有向图, 1-有向网, 2-无向图, 3-无向网）
} ALGraph;
```


#### 邻接表和邻接矩阵的异同

**联系**:
- [[邻接表]]中每个链表对应邻接矩阵中的的一行,**链表中的节点数=该行中非零元素的个数**

区别:
1. 邻接矩阵是唯一的,邻接表不唯一
2. **邻接矩阵**的空间复杂度为 O($n^2$),**邻接表**的空间复杂度为 O(n+e)

>邻接矩阵用于稠密图的存储,邻接表用于稀疏图

---

### 图的遍历

两种图的遍历方法:
1. [[深度优先搜索]]
2. [[广度优先搜索]]

效率分析:
- [[邻接表]]存储图,则[[广度优先搜索]]的时间复杂度为:==O(n+e)==
- [[邻接矩阵]]存储图:则[[广度优先搜索]]时间复杂度为:==$O(n^2)$ 

[[深度优先搜索]]和[[广度优先搜索]]的空间复杂度相同,都是==O(n)==,只与==存储结构(邻接矩阵/邻接表)有关

    

---

### [[最小生成树]]

[[最小生成树]]
在一个**带权无向连通图**中，
- **生成树**是包含所有顶点且无回路的子图。
- **最小生成树**是在所有生成树中，**边的权值之和最小**的一棵树。
> 最小生成树的n-1 条边一定包含联通网中**权值最小的边**(代价最小的边)


**求生成树的方法**
- [[Prim 算法]]: **Prim 算法每次都选“能连到新顶点的最小边”，而且不能形成环。(选点)**
- [[Kruskal算法]]:每次**选择权值最小的边**,并且不能形成环**(选边)**
> 时间复杂度:
> - [[Prim 算法]]: $O(n^2)$
> - [[Kruskal算法]]:O(eloge)




### [[拓扑排序]]

拓扑有序序列:按照[[有向图]]给出的次序关系将顶点排序成有序序列
> 图中关系的列表,顺序不唯一
> 图存在回路不能求拓扑有序序列


e.g.
![[Pasted image 20251106093636.png]]


**拓扑排序的步骤:**
1. 从[[有向图]]中选取一个没有前驱的顶点,并输出
2. 从有向图中删去此节点以及所有以他为尾的弧
3. 重复上面两步

---

### [[最短路径]]

定义:从图上A 点到 B 点路径上**权值总和最小**

**求最短路径的算法**
- 单元点(*任意两点之间*)最短路径:[[迪杰斯特拉算法]]
- 所有顶点之间(一顶点到其余顶点)的最短路径:[[佛洛依德算法]]

---
## DS- 查找
- 根据给定的值在[[查找表]]中确定一个关键字等于给定的数据元素
	-  **查找成功**:存在记录.     
	   - 结果:给出记录的完整信息/在[[查找表]]的位置
	- **查找不成功**:不存在记录
	  - 结果:给出"空指针"/"空记录"

- [[查找表]]:是**同类型的**数据元素(或记录)构成的集合

- [[关键字]]:数据元素中国某个数据项的值,可以识别一个数据元素
  - [[主关键字]]:此关键字**可以识别出唯一**的一个数据元素
  - [[次关键字]]:此关键字能识别出若干记录

---
关键字说明:

关键字类型说明:
```c
// 1. 键值类型定义 (keytype)
typedef float keytype;
// or typedef int keytype;
// or typedef char *keytype;
```
> 数据类型不确定



数据元素类型定义(ElemType):
```c
typedef struct 
{
    keytype key;
    // ...... 其他数据字段 ......
} ElemType;
```

- **查找方法评价**
	- 查找速度
	- 占用存储空间
	- 复杂程度
	- [[平均查找长度ASL]]
---
### 静态查找表

存储结构:
```c
typedef struct
{
	ElemType *elem;
	int length; //表的长度
} SSTable
```

### 顺序查找表
以*顺序表*或*线性链表*表示静态查找表
存储方式:
-  链表
- 顺序表(数组)

#### 线性查找过程

[[线性查找]]原理:
逐个比较：从数据结构的**一端开始**（通常是第一个元素），将每个元素与目标值**逐个进行比较**。

结束条件:
找到目标元素时，或遍历完所有元素仍未找到时(`i==0`)。


```c
int Search_Seq(SSTable ST, KeyType key) {
    // 在顺序表ST中顺序查找其关键字等于
    // key的数据元素。若找到，则函数值为
    // 该元素在表中的位置，否则为0。
    ST.elem[0].key = key;  // “哨兵”
    for (i=ST.length; ST.elem[i].key!=key; --i);
    // 从后往前找
    return i;  // 找不到时, i为0
} // Search_Seq
```

![[Pasted image 20251109160115.png|250]]

在0 索引的位置设置为 key 的值,防止越界.在循环只需要考虑顺序表中的数据是否匹配即可.所以`ST.elem[0].key = key` 称之为哨兵.

顺序表的[[平均查找长度ASL|平均查找长度]]为

![[Pasted image 20251109160516.png|200]]

>其中: $C_i$=n-i+1,$P_i$=1/n

[[平均查找长度ASL|平均查找长度]]大,不是用表长较大的查找表.

---

#### 有序表查找(折半查找法)

基于有序,可以使用[[折半查找]]

折半查找的性能分析
- [[判定树]]： 描述查找过程的二叉树。
- 有 n 个结点的判定树的深度为 ⌊log2​n⌋+1
- [[折半查找]]法在查找过程中进行的比较次数最多不超过 ⌊log2​n⌋+1

#### 分块查找

[[分块查找]]是一种[[平均查找长度ASL|ASL]]介于[[顺序查找]]和[[折半查找]]之间的一种查找方式.是一种比[[顺序查找]]更高效、比[[折半查找]]更灵活的查找方式。
>折半查找只适用于有序表



几种查找表的特性:

| **算法**     | **时间复杂度**    | **存储结构要求**           | **备注**                   |
| ------------ | ----------------- | -------------------------- | -------------------------- |
| **顺序查找** | $O(n)$            | 无要求（顺序、链式均可）   | 效率最低，最简单           |
| **折半查找** | $O(\log n)$       | 必须**有序**且**连续存储** | 效率极高，但维护（增删）难 |
| **分块查找** | **$O(\sqrt{n})$** | **块间有序**，块内无序     | 折中方案，兼顾查找与维护   |
- 查找性能上,表有序性能最好,能达到$O(\log n)$([[折半查找]])
- 存储结构为**链表,**插入删除性能最好,能达到$O(1)$

---

### 动态查找表
- 特点:表的结构本身是查找过程中动态生成的.
	- 表中存在关键字等于 key--->查找成功
	- 不存在关键字等于 key--->**插入**关键字等于key 的记录

#### 二叉排序树
**定义**
[[二叉排序树]]是一颗二叉树,并符合:
- 左子树**小于**根节点
- 右子树**大于**根节点
- 左右子树都是二叉排序树
>[[中序遍历]]二叉树可以得到关键字的有序排列
>[[二叉排序树]]插入节点方便





---
#### [[哈希表]]
一种用 **哈希函数把 key 映射到数组下标** 来存储数据的结构。

>核心思想：**用空间换时间，让查找接近 O(1)**。

重点:
哈希冲突的处理:[[哈希表#直接定址法]]


---
## DS-[[排序]]

基本概念:
- **排序**:是将**无序**的记录序列调整成**有序**的记录序列
- **内部排序**:整个排序过程==**不需要访问外存(存储)**==便能完成
- 外部排序:整个排序过程**不可能在内存中完成**的排序过程
- 关键字:与[[关键字|查找中的关键字]]概念相同
- [[稳定性]]:衡量一个排序算法的重要指标之一
  >**相等元素的相对次序在排序前后保持不变。**
  
  - 时间开销:衡量一个排序算法的重要指标之一.可以用**数据比较次数**与**数据移动次数**衡量.

具体的排序方法有：
### 插入排序
#### [[直接插入排序]]
**逻辑:** 对数组从左到右遍历，每次把当前元素往前移动，插到它该在的位置。

#### [[折半插入排序]]
在排序的过程中,利用有序列**有序**的特征,可以在查到插入数的位置的时候,使用[[折半查找]]法

#### [[希尔排序]]
**先让相距较远的元素进行比较与交换，使序列逐步有序，再逐步缩小间隔最终排序。**

### [[快速排序]]

#### [[冒泡排序]]
**从头到尾比较相邻的两个元素，如果顺序错了就交换，让大的慢慢“冒”到后面去。**每一次都把当前最大数字放在相应的位置上

### [[直接选择排序]]
每次找出**最小值**，与队列前方的值比较，若符合就对调

### [[堆排序]]

### [[归并排序]]

### 总结

| **排序方法**         | **平均时间**  | **最好情况**  | **最坏情况**  | **稳定性** | **辅助存储** |
| -------------------- | ------------- | ------------- | ------------- | ---------- | ------------ |
| **[[直接插入排序]]** | $O(n^2)$      | $O(n)$        | $O(n^2)$      | **稳定**   | $O(1)$       |
| **[[希尔排序]]**     | $O(n \log n)$ | $O(n \log n)$ | $O(n^2)$      | **不稳定** | $O(1)$       |
| **[[冒泡排序]]**     | $O(n^2)$      | $O(n)$        | $O(n^2)$      | **稳定**   | $O(1)$       |
| **[[快速排序]]**     | $O(n \log n)$ | $O(n \log n)$ | $O(n^2)$      | **不稳定** | $O(\log n)$  |
| **[[直接选择排序]]** | $O(n^2)$      | $O(n^2)$      | $O(n^2)$      | **稳定**   | $O(1)$       |
| **[[堆排序]]**       | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | **不稳定** | $O(1)$       |
| **[[归并排序]]**     | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | **稳定**   | $O(n)$       |
| **[[基数排序]]**     | $O(d(n+r))$   | $O(d(n+r))$   | $O(d(n+r))$   | **稳定**   | $O(r+d)$     |



  ---

## DS-[[串]]
串（string）：即字符串，是一种特殊的[[线性表]]

### 串的存储结构
1. 顺序存储结构
2. 链式存储结构

### [[串的模式匹配算法|串的模式匹配算法]]
- 简单算法
- 首位匹配算法
- [[KMP 算法]]


---

## [[DS-数组]]
**数组**:**数据类型相同的一组数据元素的有序集合**。元素在集合中的序号是由一组称做“下标”的值确定的，一个数据元素称为一个数组元素。

性质:
- 每一个数据元素都会有一个前驱后继
- 一个 N 维数组都可以看作一个线性表,则每一个数据元素可以看作一个 N-1 维的数组

### 地址计算公式
当确定的存储的首地址后,数组中任意的存储地址都可以使用一下公式确定.

**一维数组**
$$LOC(i)=LOC(i−1)+l=a+i×l,i≥0$$
**二维数组**
- 行序为主序:
$$Loc(a_{ij}​)=Loc(a_{00})+(n×i+j)×k$$
- 列序为主序
$$Loc(a_{ij}​)=Loc(a_{00})+(m×j+i)×k$$


### 矩阵的压缩存储
#### 对称矩阵
对称矩阵是一种特殊的方阵，其特点是元素满足 `m[i][j]=m[j][i]`

压缩存储的方法:只存储下三角,存储量为:**n(n+1)/2**
位置关系映射对应如下 `a[i][j]=a[k]`:

- 当 i≥j 时: **`k=i(i-1)/2+j-1`**
- 当 i<j 时: `k=j(j-1)/2+i-1`

#### 稀疏矩阵
由于元素稀缺,只存储有值的元素,为 0 忽略

压缩存储方法
##### 三元组表
每个非零元素存成一个三元组：(i, j, v)
- i：行号
- j：列号
- v：值

##### 转置运算算法
**基本算法:**
对M.data从头到尾扫描：
- **第一次扫描时**: 将 M.data 中**列号为 1** 的三元组（即 M 的第 1 列元素）赋值到 T.data 中.
- **第二次扫描时**: 将 M.data 中**列号为 2** 的三元组（即 M 的第 2 列元素）赋值到 T.data 中。
- **依此类推**: 直至将 M.data 所有三元组赋值到 T.data 中。

性能分析:
- 时间复杂度: **O(n×t)**。t 为为零元素的个数,n 为矩阵的列数
  >算法效率低


**[[快速转置算法]]:**
【基本思想】
1. **统计 A 每一列的非零元素数目**
2. **计算每行（转置后）在 B 中的起始存放位置**
3. **一次性把每个三元组放到 B 的正确位置**

性能分析:
- **时间复杂度**  O(n + t)

##### 十字链表存储
![[Pasted image 20251205214124.png|450]]
- `row`,`col`:非零元素的行,列值
- `val`:非零元素的值
- `down`:指向**同列**的下一个非零元素节点
- `right`:指向**同行**的下一个非零元素节点